import {Risco_Base_Socket} from "./RiscoChannels";
import * as Net from "net";
import {Server} from "net";

const Log_Level = require('./constants').Log_Level

export class Risco_ProxyTCP_Socket extends Risco_Base_Socket {

    private ProxyInServer: Server | null = null;
    private CloudConnected: boolean = false;
    private CloudSocket: undefined;

    constructor(SocketOptions: any) {
        super(SocketOptions, 'proxy');

        this.SocketTimeout = 120000;
        this.CloudRetryTimer = undefined;

        this.ListeningPort = SocketOptions.ListeningPort;
        this.CloudPort = SocketOptions.CloudPort;
        this.CloudUrl = SocketOptions.CloudUrl;
    }

    /*
     * Create TCP Connection
     * @return  {Promise}
     */
    async TCPConnect(): Promise<boolean> {
        return new Promise((resolve, reject) => {
            try {
                if (this.ProxyInServer === undefined) {
                    this.ProxyInServer = new Net.Server();
                    // Accept only 1 connections at the same time
                    this.ProxyInServer.maxConnections = 1;
                } else {
                    this.ProxyInServer.removeAllListeners();
                }
                this.ProxyInServer.on('error', (err) => {
                    if (err.code === 'EADDRINUSE') {
                        logger.log('error', `Cannot start Proxy ; Address already in use, retrying within 5sec...`);
                        setTimeout(() => {
                            this.ProxyInServer.close();
                            this.ProxyInServer.listen(this.ListeningPort);
                        }, 5000);
                    }
                });
                this.ProxyInServer.on('connection', (socket) => {
                    try {
                        this.Socket = socket;
                        this.CloudSocket = new Socket();
                        this.Socket.setTimeout(this.SocketTimeout);
                        this.CloudSocket.setTimeout(this.SocketTimeout);
                        this.on('BadCode', async () => {
                            // The AccessCode is incorrect.
                            // We go into a search mode to test all the codes between 0 and
                            // 999999 (maximum value).
                            // In the worst case (code 999999) the search can take up to several hours
                            // (around 100ms per test for an IPC2 card on the control panel, ie around 30 hours).
                            // Attention, access codes with one or more '0' prefixes are seen differently
                            // from the same code without the '0':
                            // 5678 != 05678 != 005678
                            const max_Password_Value = 999999;
                            if (this.DiscoverCode) {
                                logger.log('debug', `Discovery Mode Enabled.`);
                                if (this.Discovering) {
                                    do {
                                        if ((this.Password > max_Password_Value) && (this.Password_length < 6)){
                                            this.Password_length++;
                                            this.Password = 0;
                                        } else if (this.Password > max_Password_Value) {
                                            this.Disconnect();
                                        } else {
                                            this.Password++;
                                        }
                                    } while ((this.Password_length <= this.Password.toString().length) && (this.Password_length > 1));
                                } else {
                                    logger.log('error', `Bad Access Code : ${this.Password}`);
                                    this.Discovering = true;
                                    this.Password = 0;
                                    this.Password_length = 1;
                                    this.once('AccessCodeOk', () => {
                                        logger.log('verbose', `Discovered Access Code : ${this.Password}`);
                                        this.Discovering = false;
                                    });
                                }
                                let code_len = (this.Password.toString().length >= this.Password_length) ? this.Password.toString().length : this.Password_length;
                                this.Sequence_Id = 1;
                                this.PanelConnect(code_len);
                            } else {
                                logger.log('error', `Discovery Mode Is not Enabled. To Discovering Access Code, Enable it!!`);
                            }
                        });
                        this.CloudSocket.on('ready', async () => {
                            if (this.CloudRetryTimer !== undefined) {
                                clearTimeout(this.CloudRetryTimer);
                            }
                            logger.log('verbose', `Panel Socket and RiscoCloud Socket Connected.`);
                            this.IsConnected = true;
                            do {
                                await new Promise(r => setTimeout(r, 1000));
                            } while ((this.CloudConnected !== true) || (this.InRemoteConn));
                            this.PanelConnect();
                        });
                        this.Socket.once('error', (error) => {
                            logger.log('error', `Socket Error : ${error.toString()}`);
                            if (!this.CloudSocket.destroyed) {
                                this.CloudSocket.destroy(`Destroy RiscoCloud Socket due to Panel Socket Error`)
                            }
                        });
                        this.CloudSocket.on('error', (error) => {
                            if (error.code === 'ECONNREFUSED') {
                                logger.log('error', `Cannot connect to RiscoCloud, retrying within 5sec...`);
                                this.CloudSocket.end();
                                this.CloudRetryTimer = setTimeout(() => {
                                    this.CloudSocket.connect(this.CloudPort, this.CloudUrl);
                                }, 5000);
                            } else {
                                logger.log('error', `RiscoCloud Socket Error : ${error.toString()}`);
                                if (this.Socket && !this.Socket.destroyed) {
                                    this.Socket.destroy(`Destroy Panel Socket due to RiscoCloud Socket Error`);
                                }
                            }
                        });
                        this.CloudSocket.on('connect', () => {
                            if (this.CloudRetryTimer !== undefined) {
                                clearTimeout(this.CloudRetryTimer);
                            }
                        })
                        this.Socket.once('close', () => {
                            logger.log('error', `Socket Closed.`);
                            if (this.CloudRetryTimer !== undefined) {
                                clearTimeout(this.CloudRetryTimer);
                            }
                            this.Disconnect();
                        });
                        this.CloudSocket.on('close', () => {
                            if (this.CloudRetryTimer === undefined) {
                                logger.log('error', `RiscoCloud Socket Closed.`);
                                if (this.Socket && !this.Socket.destroyed) {
                                    this.Socket.end(`Close Panel Socket due to RiscoCloud Socket is Closed`);
                                    this.Disconnect();
                                }
                            }
                        });
                        this.Socket.on('timeout', () => {
                            logger.log('error', `Panel Socket Timeout.`);
                            this.Disconnect();
                        });
                        this.CloudSocket.on('timeout', () => {
                            logger.log('error', `RiscoCloud Socket Timeout.`);
                            if (this.Socket && !this.Socket.destroyed) {
                                this.Socket.end(`Close Panel Socket due to RiscoCloud Socket Timeout`);
                            }
                            this.Disconnect();
                        });
                        this.Socket.once('data', (data) => {
                            this.NewDataHandler_PanelSocket(data);
                        });
                        this.CloudSocket.once('data', (data) => {
                            this.NewDataHandler_CloudSocket(data);
                        });
                        this.CloudSocket.connect(this.CloudPort, this.CloudUrl);
                        resolve(true);
                    } catch (err) {
                        logger.log('error', `RiscoCloud Socket Error : ${error}`);
                    }
                });
                this.ProxyInServer.on('listening', () => {
                    const ProxyInfo = this.ProxyInServer.address();
                    logger.log('info', `Listening on IP ${ProxyInfo.address} and Port ${ProxyInfo.port}`);
                });
                if (!this.ProxyInServer.listening) {
                    this.ProxyInServer.listen(this.ListeningPort);
                }
            } catch (err) {
                logger.log('error', `Error on Internal Socket creation : ${err}`);
            }
        });
    }

    /*
     * Hanle new data Received on Panel Socket Side
     * @param   {Buffer}
     */
    async NewDataHandler_PanelSocket(new_output_data) {
        let StringedBuffer = this.GetStringedBuffer(new_output_data);
        if (new_output_data[1] === 19) {
            let DecryptedBuffer = new Buffer.from(new_output_data, this.encoding).toString(this.encoding);
            logger.log('debug', `Received Cloud data Buffer from Panel : ${StringedBuffer}`);
            this.CloudSocket.write(new_output_data);
        } else {
            let DecryptedBuffer = new Buffer.from(new_output_data, this.encoding).toString(this.encoding);
            if (new_output_data[1] !== 17) {
                logger.log('debug', `Received data Buffer from Panel : ${StringedBuffer}`);
                if (this.InRemoteConn) {
                    this.CloudSocket.write(new_output_data);
                } else {
                    this.NewDataHandler(new_output_data);
                }
            } else if (new_output_data[1] === 17) {
                logger.log('debug', `Received data Buffer from Panel : ${StringedBuffer}`);
                if (this.InRemoteConn) {
                    // To be able to correctly intercept the end of the remote connection, we must be able to decrypt
                    // the commands exchanged between the control panel and the RiscoCloud as soon as possible.
                    // As soon as a frame is long enough, we will check if we decode it correctly and if not we look
                    // for the decryption key.
                    let [RmtId, RmtCommandStr, RmtIsCRCOK] = this.RCrypt.DecodeMessage(new Buffer.from(new_output_data));
                    if (!RmtIsCRCOK && (new_output_data.length > 90) && !this.InCryptTest) {
                        setTimeout( r => {
                            this.InCryptTest = true;
                            let PossibleKey = 9999;
                            let TestResultOk = false;
                            do {
                                // Because the Buffer is modified by reference during decryption, a new Buffer is created on each attempt.
                                let TestBufferData = new Buffer.from(new_output_data);
                                this.RCrypt.panelId = PossibleKey;
                                this.RCrypt.UpdatePseudoBuffer();
                                [RmtId, RmtCommandStr, RmtIsCRCOK] = this.RCrypt.DecodeMessage(TestBufferData);
                                TestResultOk = (() => {
                                    if (RmtIsCRCOK) {
                                        logger.log('debug', `Panel Id is possible candidate : ${PossibleKey}`);
                                        this.InCryptTest = false;
                                        return true;
                                    } else {
                                        logger.log('debug', `Panel Id is not : ${PossibleKey}`);
                                        PossibleKey--;
                                        return false;
                                    }
                                })();
                            } while ((PossibleKey >=0) && !TestResultOk);
                        }, 50);
                    }
                    [RmtId, RmtCommandStr, RmtIsCRCOK] = this.RCrypt.DecodeMessage(new Buffer.from(new_output_data));
                    if (parseInt(RmtId, 10) === parseInt(this.LastRmtId, 10)) {
                        this.CloudSocket.write(new_output_data);
                    }
                    if (RmtCommandStr.includes('STT')) {
                        this.NewDataHandler(new_output_data);
                    }
                } else {
                    this.NewDataHandler(new_output_data);
                }
            }
        }
        this.Socket.once('data', (data) => {
            this.NewDataHandler_PanelSocket(data);
        });
    }

    /*
     * Handle new data received on Cloud Socket side
     * @param   {Buffer}
     */
    NewDataHandler_CloudSocket(new_input_data) {
        let StringedBuffer = this.GetStringedBuffer(new_input_data);
        if (new_input_data[1] === 19) {
            setTimeout(async () => {
                this.CloudConnected = true;
            }, 45000);
            logger.log('debug', `Received Cloud data Buffer from RiscoCloud : ${StringedBuffer}`);
            this.Socket.write(new_input_data);
        } else {
            this.Socket.write(new_input_data);
            let DecryptedBuffer = new Buffer.from(new_input_data, this.encoding).toString(this.encoding);
            let RmtCommandStr = undefined;
            let RmtIsCRCOK = undefined;
            [this.LastRmtId, RmtCommandStr, RmtIsCRCOK] = this.RCrypt.DecodeMessage(new Buffer.from(new_input_data));
            if (new_input_data[1] !== 17) {
                logger.log('debug', `Received Remote data Buffer from RiscoCloud : ${StringedBuffer}`);
                switch (true) {
                    case (RmtCommandStr.includes('RMT=')):
                        this.emit('IncomingRemoteConnection');
                        this.InRemoteConn = true;
                        if (this.IsConnected) {
                            const RmtPassword = RmtCommandStr.substring(RmtCommandStr.indexOf('=') + 1);
                            if (parseInt(RmtPassword, 10) === parseInt(this.Password, 10)){
                                const FakeResponse = this.RCrypt.getCommand('ACK', this.LastRmtId, false);
                                logger.log('debug', `Send Fake Response to RiscoCloud Socket : ${this.GetStringedBuffer(FakeResponse)}`);
                                this.CloudSocket.write(FakeResponse);
                            }
                        } else {
                            this.Socket.write(new_input_data);
                        }
                        break;
                    case (DecryptedBuffer.includes('LCL')):
                        if (this.IsConnected) {
                            const FakeResponse = this.RCrypt.getCommand('ACK', this.LastRmtId, false);
                            logger.log('debug', `Send Fake Response to RiscoCloud Socket : ${this.GetStringedBuffer(FakeResponse)}`);
                            this.CloudSocket.write(FakeResponse);
                        } else {
                            this.Socket.write(new_input_data);
                        }
                        break;
                    default:
                        this.Socket.write(new_input_data);
                        break;
                }
            } else if (new_input_data[1] === 17) {
                this.Socket.write(new_input_data);
                if (this.InRemoteConn && RmtIsCRCOK && RmtCommandStr.includes('DCN')) {
                    this.InRemoteConn = false;
                    const FakeResponse = this.RCrypt.getCommand('ACK', this.LastRmtId, true);
                    logger.log('debug', `Send Fake Response to RiscoCloud Socket : ${this.GetStringedBuffer(FakeResponse)}`);
                    this.CloudSocket.write(FakeResponse);
                    this.emit('EndIncomingRemoteConnection');
                }
            }
        }
        this.CloudSocket.once('data', (data) => {
            this.NewDataHandler_CloudSocket(data);
        });
    }

    /*
     * Panel connection mechanism.
     * Send command RMT + Connection password
     * Send LCL command
     * After this point, the data is encrypted.
     * @paran   {Integer}   code length (between -6)
     * @return  {Boolean}   true/false if connected or not
     */
    async PanelConnect(code_len) {
        code_len = (code_len !== undefined) ? code_len : 4;

        if (!(this.CloudConnected)) {
            await this.TCPConnect();
            // Wait 100ms for avoid slow connection
            await new Promise(r => setTimeout(r, 100));
        }

        let PossibleKey = 9999;
        let ConnectPanel;

        ConnectPanel = await this.SendCommand(`RMT=${this.Password.toString().padStart(code_len, '0')}`)
            .then( async (data) => {
                if ((data !== undefined) && data && (data.includes('ACK') === true)) {
                    if (this.Discovering) {
                        logger.log('debug', `Access Code is Ok : ${this.Password}`);
                        this.emit('AccessCodeOk');
                        this.Discovering = false;
                    }
                    return await this.SendCommand(`LCL`);
                } else if (this.IsErrorCode(data) && !this.Disconnecting) {
                    this.emit('BadCode');
                    return false;
                } else {
                    return false;
                }
            })
            .then( async (data) => {
                if (data && data.includes('ACK') === true) {
                    // Now, Encrypted channel is enabled
                    let CryptResult = true;
                    let TestBuffer;
                    this.RCrypt.CryptCommand = true;
                    await new Promise(r => setTimeout(r, 1000));
                    this.InCryptTest = true;
                    [CryptResult, TestBuffer] = await this.CryptTableTester();
                    if (this.DiscoverCode && !this.CryptKeyValidity) {
                        logger.log('debug', `Bad Panel Id : ${this.RCrypt.panelId}.`);
                        let CryptedResponseBuffer = new Buffer.from(TestBuffer);
                        this.emit('BadCryptKey');
                        this.once('CryptKeyOk', () => {
                            logger.log('verbose', `Discovered Panel Id : ${this.RCrypt.panelId}.`);
                            this.InCryptTest = false;
                        });
                        let TestResultOk = false;
                        do {
                            do {
                                // Because the Buffer is modified by reference during decryption, a new Buffer is created on each attempt.
                                let TestBufferData = new Buffer.from(CryptedResponseBuffer);
                                this.RCrypt.panelId = PossibleKey;
                                this.RCrypt.UpdatePseudoBuffer();
                                let [Receive_Id, ReceiveCommandStr, IsCRCOK] = this.RCrypt.DecodeMessage(TestBufferData);
                                TestResultOk = (() => {
                                    if (IsCRCOK) {
                                        logger.log('debug', `Panel Id is possible candidate : ${PossibleKey}`);
                                        return true;
                                    } else {
                                        logger.log('debug', `Panel Id is not : ${PossibleKey}`);
                                        PossibleKey--;
                                        return false;
                                    }
                                })();
                            } while ((PossibleKey >=0) && !TestResultOk);

                            [CryptResult, ] = await this.CryptTableTester();
                            if ((PossibleKey >= 0) && (CryptResult)) {
                                await new Promise(r => setTimeout(r, 1000));
                                this.InCryptTest = false;
                                this.emit('CryptKeyOk');
                            } else if ((PossibleKey < 0)) {
                                this.InCryptTest = false;
                            } else {
                                this.InCryptTest = true;
                                // Reauth and restart test from actual PossibleKey
                                await new Promise(r => setTimeout(r, 100));
                                PossibleKey--;
                            }
                        } while (!ConnectPanel && this.InCryptTest);
                        // Empty buffer socket???
                        await new Promise(r => setTimeout(r, 2000));
                    }
                    this.InCryptTest = false;
                    return CryptResult;
                } else {
                    return false;
                }
            })
            .catch( (err) => {
                return false;
            });

        if (!this.Discovering) {
            if (ConnectPanel !== false) {
                logger.log('debug', `Connection to the control panel successfully established.`);
                this.IsConnected = true;
                this.emit('PanelConnected');
            } else {
                logger.log('error', `Error when connecting to the control panel.`);
                this.Disconnect();
            }
        }
    }

    /*
     * Disconnects the Socket and stops the WatchDog function
     */
    async Disconnect() {
        this.Disconnecting = true;
        this.ProxyInServer.close();
        this.emit('Disconnected');
        if ((this.Socket !== undefined) && (!this.Socket.destroyed)) {
            this.IsConnected = this.CloudConnected = false;
            clearTimeout(this.WatchDogTimer);
            await this.SendCommand('DCN');
            if (this.Socket !== undefined) {
                this.Socket.removeAllListeners();
                this.Socket.destroy();
                this.Socket = undefined;
                logger.log('debug', `Socket Destroyed.`);
            }
        }
        if ((this.CloudSocket !== undefined) && (!this.CloudSocket.destroyed)) {
            this.CloudSocket.destroy();
            logger.log('debug', `RiscoCloud Socket Destroyed.`);
            this.CloudSocket.removeAllListeners();
            this.CloudSocket = undefined;
        }
        this.CloudConnected = false;
    }
}